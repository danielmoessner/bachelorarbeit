
% Refereed Journal Papers and Book Chapters
% (To appear under 'Articles in journal or book chapters' in the publications listing on the web site.)

%% This is db's personal bibliography.
%% Publication web page is generated from this file.


% The 'keyword' field contains always the basic research interest,
%   which the paper falls into, must be one of the following:
%   - Interfaces for Component-Based Design
%   - Software Model Checking
%   - Structural Analysis and Comprehension
%   - Formal Verification of Real-Time Systems
%   - Software Testing



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

To be published:

%% FMSD (CAV07)
Article{FMSD,
  author =     {Dirk Beyer and Thomas A. Henzinger and 
                Gr{\'e}gory Th{\'e}oduloz},
  title =      {Configurable Software Verification: 
                Concretizing the Convergence of 
                Model Checking and Program Analysis},
  journal =    {International Journal on 
                Formal Methods in System Design (FMSD)},
  year =       {Under revision.
                Invited to special issue of selected papers from CAV 2007},
}

%% TOPLAS (CAV06)
Article{TOPLAS,
  author =     {Dirk Beyer and Thomas A. Henzinger and 
                Gr{\'e}gory Th{\'e}oduloz},
  title =      {Lazy Shape Analysis},
  journal =    {ACM Transactions on 
                Programming Languages and Systems (TOPLAS)},
  year =       {Under revision},
}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 2018

%%125 Benchmarking
@Article{Benchmarking-STTT,
  author    = {Dirk Beyer and Stefan L{\"o}we and Philipp Wendler},
  title     = {Reliable Benchmarking: {R}equirements and Solutions},
  journal   = {International Journal on Software Tools for Technology Transfer (STTT)},
  volume    = {21},
  number    = {1},
  pages     = {1--29},
  year      = {2019},
  doi       = {10.1007/s10009-017-0469-y},
  pdf       = {https://www.sosy-lab.org/research/pub/2019-STTT.Reliable_Benchmarking_Requirements_and_Solutions.pdf},
  url       = {https://www.sosy-lab.org/research/benchmarking/},
  postscript= {https://www.sosy-lab.org/research/prs/Current_ReliableBenchmarking.pdf},
  abstract  = {Benchmarking is a widely used method in experimental computer science,
               in particular, for the comparative evaluation of tools and algorithms.
               As a consequence, a number of questions need to be answered
               in order to ensure proper benchmarking, resource measurement, and presentation of results,
               all of which is essential for researchers, tool developers, and users, as well as for tool competitions.
               We identify a set of requirements that are indispensable for reliable benchmarking and resource measurement
               of time and memory usage of automatic solvers, verifiers, and similar tools,
               and discuss limitations of existing methods and benchmarking tools.
               Fulfilling these requirements in a benchmarking framework can (on Linux systems)
               currently only be done by using the cgroup and namespace features of the kernel.
               We developed BenchExec, a ready-to-use, tool-independent, and open-source implementation
               of a benchmarking framework that fulfills all presented requirements,
               making reliable benchmarking and resource measurement easy.
               Our framework is able to work with a wide range of different tools,
               has proven its reliability and usefulness in the International Competition on Software Verification,
               and is used by several research groups worldwide to ensure reliable benchmarking.
               Finally, we present guidelines on how to present measurement results
               in a scientifically valid and comprehensible way.
              },
  keyword   = {Benchmarking},
  annote    = {DOI: <a href="https://doi.org/10.1007/s10009-017-0469-y">10.1007/s10009-017-0469-y</a><BR/>
               Publication appeared first online in November 2017<BR/>
               BenchExec is available at:
               <a href="https://github.com/sosy-lab/benchexec">
               https://github.com/sosy-lab/benchexec</a>},
}

%%131 Handbook of Model Checking
@InCollection{HBMC18,
  author    = {Dirk Beyer and Sumit Gulwani and David Schmidt},
  title     = {Combining Model Checking and Data-Flow Analysis},
  booktitle = {Handbook on Model Checking},
  editor    = {E.~M.~Clarke and T.~A.~Henzinger and H.~Veith and R.~Bloem},
  publisher = {Springer},
  pages     = {493-540},
  year      = {2018},
  doi       = {10.1007/978-3-319-10575-8_16},
  pdf       = {https://www.sosy-lab.org/research/pub/2018-HBMC.Combining_Model_Checking_and_Data-Flow_Analysis.pdf},
  isbn      = {978-3-319-10574-1},
  annote    = {DOI: <a href="https://doi.org/10.1007/978-3-319-10575-8_16">10.1007/978-3-319-10575-8_16</a>},
}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 2017

%%127 SMT-Based Algorithms
@Article{AlgorithmComparison-JAR,
  author    = {Dirk Beyer and Matthias Dangl and Philipp Wendler},
  title     = {A Unifying View on {SMT}-Based Software Verification},
  journal   = {Journal of Automated Reasoning},
  year      = {2018},
  volume    = {60},
  number    = {3},
  pages     = {299--335},
  issn      = {1573-0670},
  doi       = {10.1007/s10817-017-9432-6},
  pdf       = {https://www.sosy-lab.org/research/pub/2018-JAR.A_Unifying_View_on_SMT-Based_Software_Verification.pdf},
  url       = {https://www.sosy-lab.org/research/k-ind-compare/},
  postscript= {https://www.sosy-lab.org/research/prs/Current_UnifyingViewSmtBasedSoftwareVerification.pdf},
  abstract  = {After many years of successful development of new approaches for software verification,
               there is a need to consolidate the knowledge about the different abstract domains and algorithms.
               The goal of this paper is to provide a compact and accessible presentation of
               four SMT-based verification approaches in order to study them in theory and in practice.
               We present and compare the following different ``schools of thought'' of software verification:
               bounded model checking, k-induction, predicate abstraction, and lazy abstraction with interpolants.
               Those approaches are well-known and successful in software verification
               and have in common that they are based on SMT solving as the back-end technology.
               We reformulate all four approaches in the unifying theoretical framework
               of configurable program analysis
               and implement them in the verification framework CPAchecker.
               Based on this, we can present an evaluation that thoroughly compares the different approaches,
               where the core differences are expressed in configuration parameters
               and all other variables are kept constant
               (such as parser front end, SMT solver, used theory in SMT formulas).
               We evaluate the effectiveness and the efficiency of the approaches
               on a large set of verification tasks
               and discuss the conclusions.
              },
  keyword   = {CPAchecker,Software Model Checking},
  annote    = {DOI: <a href="https://doi.org/10.1007/s10817-017-9432-6">10.1007/s10817-017-9432-6</a><BR/>
               Publication appeared first online in December 2017<BR/>
               CPAchecker is available at:
               <a href="https://cpachecker.sosy-lab.org/">
               https://cpachecker.sosy-lab.org/</a>},
}

%%124 SpringerBuch-50JahreInfMUC
@InCollection{InfMUC17,
  author    = {Dirk Beyer and Rolf Hennicker and Martin Hofmann and 
                Tobias Nipkow and Martin Wirsing},
  title     = {Software-Verifikation},
  booktitle = {50 Jahre Universit{\"a}ts-Informatik in M{\"u}nchen},
  editor    = {A.~Bode and M.~Broy and H.-J.~Bungartz and F.~Matthes},
  publisher = {Springer},
  pages     = {75-86},
  year      = {2017},
  isbn      = {978-3-662-54711-3},
  doi       = {10.1007/978-3-662-54712-0_5},
  pdf       = {https://www.sosy-lab.org/research/pub/2017-50JahreInfMUC.Software-Verifikation.pdf},
  keyword   = {Software Model Checking},
  annote    = {DOI: <a href="https://doi.org/10.1007/978-3-662-54712-0_5">10.1007/978-3-662-54712-0_5</a>},
}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 2014

%%97
@article{STTT14-BDD,
  author    = {Dirk Beyer and Andreas Stahlbauer},
  title     = {{BDD}-Based Software Verification: Applications to Event-Condition-Action Systems},
  journal   = {International Journal on Software Tools for Technology Transfer (STTT)},
  volume    = {16},
  number    = {5},
  pages     = {507--518},
  year      = {2014},
  doi       = {10.1007/s10009-014-0334-1},
  pdf       = {https://www.sosy-lab.org/research/pub/2014-STTT.BDD-Based_Software_Verification.pdf},
  url       = {https://doi.org/10.1007/s10009-014-0334-1},
  keyword   = {CPAchecker,Software Model Checking},
  annote    = {DOI: <a href="https://doi.org/10.1007/s10009-014-0334-1">10.1007/s10009-014-0334-1</a>},
}

%%96
@article{STTT14-Intro,
  author    = {Falk Howar and Malte Isberner and Maik Merten and Bernhard Steffen and Dirk Beyer and Corina S. Pasareanu},
  title     = {Rigorous examination of reactive systems: The {RERS} challenges 2012 and 2013},
  journal   = {International Journal on Software Tools for Technology Transfer (STTT)},
  volume    = {16},
  number    = {5},
  pages     = {457--464},
  year      = {2014},
  doi       = {10.1007/s10009-014-0337-y},
  pdf       = {https://www.sosy-lab.org/research/pub/2014-STTT.Rigorous_Examination_of_Reactive_Systems.pdf},
  url       = {https://doi.org/10.1007/s10009-014-0337-y},
  annote    = {DOI: <a href="https://doi.org/10.1007/s10009-014-0337-y">10.1007/s10009-014-0337-y</a>},
}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 2007

%%54
@Article{STTT07,
  author =     {Dirk Beyer and Thomas A. Henzinger and Ranjit Jhala and Rupak Majumdar},
  title =      {The Software Model Checker {{\sc Blast}}:
                Applications to Software Engineering},
  journal =    {International Journal on 
                Software Tools for Technology Transfer (STTT)},
  volume =     {9},
  number =     {5-6},
  year =       {2007.
                Invited to special issue of selected papers from FASE 2004/05},
  pages =      {505-525},
  keyword =    {Software Model Checking},
  doi =        {10.1007/s10009-007-0044-z},
  pdf =        {https://www.sosy-lab.org/research/pub/2007-STTT.The_Software_Model_Checker_BLAST.pdf},
  url =        {},
  postscript = {https://www.sosy-lab.org/research/prs/2008-05-08_EPFL_BLAST_Dirk.pdf},
  abstract =   {
                BLAST is an automatic verification tool for checking
                temporal safety properties of C programs. Given a C
                program and a temporal safety property, BLAST either
                statically proves that the program satisfies the
                safety property, or provides an execution path that
                exhibits a violation of the property (or, since the
                problem is undecidable, does not terminate).  BLAST
                constructs, explores, and refines abstractions of the
                program state space based on lazy predicate
                abstraction and interpolation-based predicate
                discovery. This paper gives an introduction to BLAST
                and demonstrates, through two case studies, how it can
                be applied to program verification and test-case
                generation. In the first case study, we use BLAST to
                statically prove memory safety for C programs.  We use
                CCured, a type-based memory-safety analyzer, to
                annotate a program with run-time assertions that check
                for safe memory operations. Then, we use BLAST to
                remove as many of the run-time checks as possible (by
                proving that these checks never fail), and to generate
                execution scenarios that violate the assertions for
                the remaining run-time checks.  In our second case
                study, we use BLAST to automatically generate test
                suites that guarantee full coverage with respect to a
                given predicate. Given a C program and a target
                predicate p, BLAST determines the program locations q
                for which there exists a program execution that
                reaches q with p true, and automatically generates a
                set of test vectors that cause such executions. Our
                experiments show that BLAST can provide automated,
                precise, and scalable analysis for C programs.
                },
  annote =     {DOI: <a href="https://doi.org/10.1007/s10009-007-0044-z">10.1007/s10009-007-0044-z</a><BR/>
                BLAST is available at:
                <a href="http://www.sosy-lab.org/~dbeyer/Blast/">
                http://www.sosy-lab.org/~dbeyer/Blast</a>
               },
  keyword   =  {BLAST,Software Model Checking},
}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 2005

%%33
@Article{TSE05,
  author =     {Dirk Beyer and Andreas Noack and Claus Lewerentz},
  title =      {Efficient Relational Calculation for Software Analysis},
  journal =    {IEEE Transactions on Software Engineering (TSE)},
  volume =     {31},
  number =     {2},
  year =       {2005.
                Invited to special issue of selected papers from WCRE 2003},
  pages =      {137-149},
  keyword =    {Structural Analysis and Comprehension},
  doi        = {10.1109/TSE.2005.23},
  pdf =        {https://www.sosy-lab.org/research/pub/2005-TSE.Efficient_Relational_Calculation_for_Software_Analysis.pdf},
  url =        {http://repositories.cdlib.org/postprints/687},
  abstract =   {
                Calculating with graphs and relations has many
                applications in the analysis of software systems, for
                example, the detection of design patterns or patterns
                of problematic design and the computation of design
                metrics. These applications require an expressive
                query language, in particular, for the detection of
                graph patterns, and an efficient evaluation of the
                queries even for large graphs. In this paper, we
                introduce RML, a simple language for querying and
                manipulating relations based on predicate calculus,
                and CrocoPat, an interpreter for RML programs. RML is
                general because it enables the manipulation not only
                of graphs (i.e., binary relations), but of relations
                of arbitrary arity. CrocoPat executes RML programs
                efficiently because it internally represents relations
                as binary decision diagrams, a data structure that is
                well-known as a compact representation of large
                relations in computer-aided verification. We evaluate
                RML by giving example programs for several software
                analyses and CrocoPat by comparing its performance
                with calculators for binary relations, a Prolog
                system, and a relational database management system.
                },
  annote =     {DOI: <a href="https://doi.org/10.1109/TSE.2005.23">10.1109/TSE.2005.23</a><BR/>
                Also available as postprint at the eScholarship Repository, University of California: <BR>
                <a href="http://repositories.cdlib.org/postprints/687">
                http://repositories.cdlib.org/postprints/687</a> <BR>
                CrocoPat is available at:
                <a href="http://www.sosy-lab.org/~dbeyer/CrocoPat/">
                http://www.sosy-lab.org/~dbeyer/CrocoPat</a>
               },
}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 2003

%%21b
@Article{SW-Trends03,
  author =     {Dirk Beyer},
  title =      {Formale Verifikation von Realzeit-Systemen
                  mittels Cottbus Timed Automata (Zusammenfassung)},
  journal =    {Softwaretechnik-Trends},
  publisher =  {Gesellschaft f{\"u}r Informatik, Berlin},
  volume =     {23},
  number =     {2},
  pages =      {4},
  month =      {May},
  year =       {2003},
  issn =       {0720-8928},
  annote =     {Summary of dissertation},
}
